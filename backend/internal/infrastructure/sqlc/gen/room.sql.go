// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: room.sql

package gen

import (
	"context"

	"github.com/google/uuid"
)

const createRoom = `-- name: CreateRoom :exec
INSERT INTO rooms(
    id,
    organization_id,
    name,
    building_name,
    floor_number,
    room_type,
    description
)
VALUES(
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
`

type CreateRoomParams struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	Name           string
	BuildingName   string
	FloorNumber    string
	RoomType       string
	Description    string
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) error {
	_, err := q.db.Exec(ctx, createRoom,
		arg.ID,
		arg.OrganizationID,
		arg.Name,
		arg.BuildingName,
		arg.FloorNumber,
		arg.RoomType,
		arg.Description,
	)
	return err
}

const getAllRooms = `-- name: GetAllRooms :many
SELECT r.id, r.organization_id, r.name, r.building_name, r.floor_number, r.room_type, r.description, r.created_at, r.updated_at
FROM rooms r
ORDER BY created_at DESC
`

type GetAllRoomsRow struct {
	Room Room
}

func (q *Queries) GetAllRooms(ctx context.Context) ([]GetAllRoomsRow, error) {
	rows, err := q.db.Query(ctx, getAllRooms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRoomsRow
	for rows.Next() {
		var i GetAllRoomsRow
		if err := rows.Scan(
			&i.Room.ID,
			&i.Room.OrganizationID,
			&i.Room.Name,
			&i.Room.BuildingName,
			&i.Room.FloorNumber,
			&i.Room.RoomType,
			&i.Room.Description,
			&i.Room.CreatedAt,
			&i.Room.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomById = `-- name: GetRoomById :one
SELECT r.id, r.organization_id, r.name, r.building_name, r.floor_number, r.room_type, r.description, r.created_at, r.updated_at
FROM rooms r
WHERE r.id = $1
`

type GetRoomByIdRow struct {
	Room Room
}

func (q *Queries) GetRoomById(ctx context.Context, id uuid.UUID) (GetRoomByIdRow, error) {
	row := q.db.QueryRow(ctx, getRoomById, id)
	var i GetRoomByIdRow
	err := row.Scan(
		&i.Room.ID,
		&i.Room.OrganizationID,
		&i.Room.Name,
		&i.Room.BuildingName,
		&i.Room.FloorNumber,
		&i.Room.RoomType,
		&i.Room.Description,
		&i.Room.CreatedAt,
		&i.Room.UpdatedAt,
	)
	return i, err
}

const getRoomsByTenant = `-- name: GetRoomsByTenant :many
SELECT r.id, r.organization_id, r.name, r.building_name, r.floor_number, r.room_type, r.description, r.created_at, r.updated_at
FROM rooms r
INNER JOIN room_assignments ra ON r.id = ra.room_id
WHERE ra.tenant_id = $1
  AND (ra.expires_at IS NULL OR ra.expires_at > NOW())
ORDER BY r.created_at DESC
`

type GetRoomsByTenantRow struct {
	Room Room
}

func (q *Queries) GetRoomsByTenant(ctx context.Context, tenantID uuid.UUID) ([]GetRoomsByTenantRow, error) {
	rows, err := q.db.Query(ctx, getRoomsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomsByTenantRow
	for rows.Next() {
		var i GetRoomsByTenantRow
		if err := rows.Scan(
			&i.Room.ID,
			&i.Room.OrganizationID,
			&i.Room.Name,
			&i.Room.BuildingName,
			&i.Room.FloorNumber,
			&i.Room.RoomType,
			&i.Room.Description,
			&i.Room.CreatedAt,
			&i.Room.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
