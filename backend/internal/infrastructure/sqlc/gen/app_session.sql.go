// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: app_session.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredAppSessions = `-- name: CleanupExpiredAppSessions :exec
DELETE FROM sessions
WHERE expires_at < NOW() OR revoked = TRUE
`

// 期限切れまたは無効化されたセッションを物理削除する（バッチ処理用）
func (q *Queries) CleanupExpiredAppSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredAppSessions)
	return err
}

const createAppSession = `-- name: CreateAppSession :one
INSERT INTO sessions (
    session_id,
    user_id,
    active_membership_id,
    created_at,
    expires_at,
    csrf_token,
    revoked
) VALUES (
    $1, $2, $3, $4, $5, $6, FALSE
) RETURNING sessions.session_id, sessions.user_id, sessions.active_membership_id, sessions.created_at, sessions.expires_at, sessions.csrf_token, sessions.revoked
`

type CreateAppSessionParams struct {
	SessionID          string
	UserID             uuid.UUID
	ActiveMembershipID *uuid.UUID
	CreatedAt          pgtype.Timestamptz
	ExpiresAt          pgtype.Timestamptz
	CsrfToken          *string
}

type CreateAppSessionRow struct {
	Session Session
}

func (q *Queries) CreateAppSession(ctx context.Context, arg CreateAppSessionParams) (CreateAppSessionRow, error) {
	row := q.db.QueryRow(ctx, createAppSession,
		arg.SessionID,
		arg.UserID,
		arg.ActiveMembershipID,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.CsrfToken,
	)
	var i CreateAppSessionRow
	err := row.Scan(
		&i.Session.SessionID,
		&i.Session.UserID,
		&i.Session.ActiveMembershipID,
		&i.Session.CreatedAt,
		&i.Session.ExpiresAt,
		&i.Session.CsrfToken,
		&i.Session.Revoked,
	)
	return i, err
}

const getAppSession = `-- name: GetAppSession :one
SELECT s.session_id, s.user_id, s.active_membership_id, s.created_at, s.expires_at, s.csrf_token, s.revoked
FROM sessions s
WHERE s.session_id = $1
AND s.revoked = FALSE
`

type GetAppSessionRow struct {
	Session Session
}

func (q *Queries) GetAppSession(ctx context.Context, sessionID string) (GetAppSessionRow, error) {
	row := q.db.QueryRow(ctx, getAppSession, sessionID)
	var i GetAppSessionRow
	err := row.Scan(
		&i.Session.SessionID,
		&i.Session.UserID,
		&i.Session.ActiveMembershipID,
		&i.Session.CreatedAt,
		&i.Session.ExpiresAt,
		&i.Session.CsrfToken,
		&i.Session.Revoked,
	)
	return i, err
}

const revokeAppSession = `-- name: RevokeAppSession :exec
UPDATE sessions
SET revoked = TRUE
WHERE session_id = $1
`

func (q *Queries) RevokeAppSession(ctx context.Context, sessionID string) error {
	_, err := q.db.Exec(ctx, revokeAppSession, sessionID)
	return err
}
